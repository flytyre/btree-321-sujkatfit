import java.util.ArrayList;

/**
 * B-Tree node class.
 * Generic.
 * @author ksilva
 * @param <K> Generic type.
 */
public class Node<K> {
	
	private Node parent;
	private ArrayList<Node> children;
	private ArrayList<TreeObject> keys;
	private int degree;
	
	/**
	 * Constructor.
	 * @param key The generic type object to store in this node.
	 */
	public Node(int degree) {
		parent = null;

		children = new ArrayList<Node>();
		
		this.degree = degree;
		keys = new ArrayList<TreeObject>();
		
	}
	
	
	/**
	 * Sets the given node as this node's parent.
	 * Allows setting to null.
	 * @param parent The new parent of this node.
	 */
	public void setParent(Node parent) {
		this.parent = parent;
	}

	
	/**
	 * Returns this node's parent.
	 * @return parent The parent of this node.
	 */
	public Node getParent() {
		return parent;
	}

	
	/**
	 * Sets the given node as this node's left child.
	 * Allows setting to null.
	 * @param left The new left child of this node.
	 */
	public void setChild(int index, Node child) {
		if (index >= 0 && index < keys.size()) {
			children.set(index, child);
		}
	}


	/**
	 * Returns the child node at the given index.
	 * @return left The child node at the given index.
	 */
	public Node getChild(int index) {
		if (index >= 0 && index < keys.size()) {
			return children.get(index);
		}
		return null;
	}
	
	
	/**
	 * Gets the key at the given index.
	 * @param index The given index.
	 * @return keys.get(index) The key at the given index.
	 */
	public TreeObject getKey(int index) {
		if (index >= 0 && index < keys.size()) {
			return keys.get(index);
		}
		return null;	
	}
	
	
	/**
	 * Gets the key at the given index.
	 * @param index The given index.
	 * @return keys.get(index) The key at the given index.
	 */
	public TreeObject removeKey(int index) {
		if (index >= 0 && index < keys.size()) {
			return keys.remove(index);
		}
		return null;	
	}
	
	
	public int getNumKeys() {
		return keys.size();
	}

	
	/**
	 * Adds a key to the tree.
	 * @param adding
	 * @return
	 */
	public boolean addKey(TreeObject adding) {
		if (keys.size() < degree) {
			int next = 0;
			
			for (int i = 0; i < keys.size(); i++) {
				int result = adding.compare(keys.get(i));
				if (result <= 0) {
					if (result != 0) {
						keys.add(i, adding);
					} else {
						keys.get(i).incFrequency();						
					}
					return true;
				} 
			}
		}
		return false;
	}
	
	
	/**
	 * Returns whether or not this node is a leaf.
	 */
	public boolean isLeaf() {
		if (children.size() != 0) {
			return false;
		}
		return true;
	}
	
}
